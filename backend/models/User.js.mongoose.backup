// ============================================================================
// OREPA Backend - User Model (Prisma)
// ============================================================================
//
// Purpose:
//   Defines the User model methods for PostgreSQL using Prisma
//   Handles user authentication, authorization, and profile management
//
// Features:
//   - Email-based authentication
//   - Password hashing with bcrypt
//   - Role-based access control (user, member, admin, superadmin)
//   - User status management (pending, approved, rejected)
//   - Helper methods for user operations
//
// Dependencies:
//   - @prisma/client: PostgreSQL ORM
//   - bcryptjs: Password hashing
//
// Usage:
//   const UserModel = require('./models/User');
//   const user = await UserModel.create({ email, password, firstName, lastName });
//
// ============================================================================

const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

const prisma = new PrismaClient();

// ============================================================================
// USER SCHEMA DEFINITION
// ============================================================================

/**
 * User Schema
 *
 * Defines the structure of user documents in MongoDB
 * Includes validation rules, indexes, and schema options
 */
const userSchema = new mongoose.Schema(
  {
    // ========================================================================
    // AUTHENTICATION FIELDS
    // ========================================================================

    /**
     * Email Address
     * - Primary identifier for user authentication
     * - Must be unique across all users
     * - Automatically converted to lowercase
     * - Validated with regex pattern
     */
    email: {
      type: String,
      required: [true, 'Email address is required'],
      unique: true,
      lowercase: true,                              // Convert to lowercase before saving
      trim: true,                                   // Remove whitespace
      match: [
        /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
        'Please provide a valid email address',
      ],
      index: true,                                  // Create index for faster queries
    },

    /**
     * Password
     * - Stored as bcrypt hash (never plain text)
     * - Minimum 6 characters required
     * - Automatically hashed before saving (see pre-save hook)
     * - Excluded from JSON responses (see toJSON transform)
     */
    password: {
      type: String,
      required: [true, 'Password is required'],
      minlength: [6, 'Password must be at least 6 characters'],
      select: false,                                // Don't include in queries by default
    },

    // ========================================================================
    // PROFILE FIELDS
    // ========================================================================

    /**
     * First Name
     * - User's given name
     * - Trimmed of whitespace
     */
    firstName: {
      type: String,
      required: [true, 'First name is required'],
      trim: true,
      maxlength: [50, 'First name cannot exceed 50 characters'],
    },

    /**
     * Last Name
     * - User's family name
     * - Trimmed of whitespace
     */
    lastName: {
      type: String,
      required: [true, 'Last name is required'],
      trim: true,
      maxlength: [50, 'Last name cannot exceed 50 characters'],
    },

    /**
     * Name with Initials
     * - Full name with initials (e.g., A.B.C. Perera)
     */
    nameWithInitials: {
      type: String,
      required: [true, 'Name with initials is required'],
      trim: true,
      maxlength: [100, 'Name cannot exceed 100 characters'],
    },

    /**
     * Date of Birth
     */
    dateOfBirth: {
      type: Date,
      required: [true, 'Date of birth is required'],
    },

    /**
     * Address
     */
    address: {
      type: String,
      required: [true, 'Address is required'],
      trim: true,
    },

    /**
     * Country
     */
    country: {
      type: String,
      default: 'Sri Lanka',
      trim: true,
    },

    /**
     * Phone Number
     * - Contact phone number
     * - Not required but validated if provided
     */
    phone: {
      type: String,
      required: [true, 'Phone number is required'],
      trim: true,
      match: [
        /^[\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6}$/,
        'Please provide a valid phone number',
      ],
    },

    // ========================================================================
    // ACADEMIC & PROFESSIONAL FIELDS
    // ========================================================================

    /**
     * Batch of School
     * - Year user entered/left school batch
     */
    batch: {
      type: Number,
      required: [true, 'Batch year is required'],
    },

    /**
     * School Admission Number
     */
    admissionNumber: {
      type: String,
      required: [true, 'Admission number is required'],
      trim: true,
    },

    /**
     * A/L Shy
     * - 1st shy, 2nd shy, etc.
     */
    alShy: {
      type: String,
      required: [true, 'A/L shy is required'],
      enum: ['1st shy', '2nd shy', '3rd shy'],
    },

    /**
     * University
     */
    university: {
      type: String,
      required: [true, 'University is required'],
      trim: true,
    },

    /**
     * Faculty
     */
    faculty: {
      type: String,
      required: [true, 'Faculty is required'],
      trim: true,
    },

    /**
     * Current University Level
     */
    universityLevel: {
      type: String,
      required: [true, 'University level is required'],
      enum: ['First Year', 'Second Year', 'Third Year', 'Fourth Year', 'Graduated', 'Other'],
    },

    /**
     * Engineering Field
     */
    engineeringField: {
      type: String,
      required: [true, 'Engineering field is required'],
      trim: true,
    },

    /**
     * OREPA Student Chapter ID
     * - Assigned by admins
     */
    orepaSCId: {
      type: String,
      default: null,
      trim: true,
    },

    // ========================================================================
    // AUTHORIZATION FIELDS
    // ========================================================================

    /**
     * Role
     * - Determines user permissions and access levels
     * - Default: 'USER' (basic access)
     * - MEMBER: Verified OREPA member
     * - MEMBER_ADMIN: Manages user registrations and member data
     * - CONTENT_ADMIN: Manages projects, LMS, scholarships, media
     * - NEWSLETTER_ADMIN: Manages newsletters and subscribers
     * - SUPER_ADMIN: Full system access with all permissions
     */
    role: {
      type: String,
      enum: {
        values: ['USER', 'MEMBER', 'MEMBER_ADMIN', 'CONTENT_ADMIN', 'NEWSLETTER_ADMIN', 'SUPER_ADMIN'],
        message: '{VALUE} is not a valid role',
      },
      default: 'USER',
    },

    /**
     * Is Admin Flag
     * - Quick check to determine if user has admin privileges
     * - Automatically set to true for admin roles via pre-save hook
     * - Used for fast admin authorization checks
     */
    isAdmin: {
      type: Boolean,
      default: false,
      index: true,                                  // Create index for admin queries
    },

    /**
     * Status
     * - Tracks user account approval status
     * - PENDING: New registration, awaiting approval
     * - APPROVED: Account approved, full access granted
     * - REJECTED: Account rejected, access denied
     * - SUSPENDED: Account temporarily suspended
     */
    status: {
      type: String,
      enum: {
        values: ['PENDING', 'APPROVED', 'REJECTED', 'SUSPENDED'],
        message: '{VALUE} is not a valid status',
      },
      default: 'PENDING',
      index: true,                                  // Create index for status queries
    },

    /**
     * Approved By
     * - Reference to the admin who approved this user account
     * - Only populated when status changes to APPROVED
     * - Used for accountability and audit trails
     */
    approvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      default: null,
    },

    /**
     * Approval Date
     * - Timestamp when account was approved
     * - Used for tracking and analytics
     */
    approvalDate: {
      type: Date,
      default: null,
    },

    /**
     * Created By
     * - Reference to the admin who created this account
     * - Only populated for admin-created accounts (not self-registrations)
     * - Used to track which Super Admin created other admin accounts
     */
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      default: null,
    },

    /**
     * Login Attempts
     * - Tracks failed login attempts for security
     * - Incremented on failed login, reset on successful login
     * - Used for account lockout mechanism
     */
    loginAttempts: {
      type: Number,
      default: 0,
      min: 0,
    },

    /**
     * Account Locked Until
     * - Timestamp until which account is locked
     * - Set after maximum failed login attempts
     * - Account automatically unlocks after this time
     */
    accountLockedUntil: {
      type: Date,
      default: null,
    },

    // ========================================================================
    // PROFILE PICTURE (Future Enhancement)
    // ========================================================================

    /**
     * Profile Picture URL
     * - URL to user's profile picture
     * - Can be local storage or cloud storage (S3, Cloudinary, etc.)
     */
    profilePicture: {
      type: String,
      default: null,
    },

    // ========================================================================
    // METADATA FIELDS
    // ========================================================================

    /**
     * Last Login
     * - Timestamp of user's most recent login
     * - Updated on successful authentication
     */
    lastLogin: {
      type: Date,
      default: null,
    },

    /**
     * Email Verification (Future Enhancement)
     * - Indicates if user has verified their email address
     */
    isEmailVerified: {
      type: Boolean,
      default: false,
    },

    /**
     * Account Active Status
     * - Allows soft deletion of accounts
     * - Inactive accounts cannot log in
     */
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    // ========================================================================
    // SCHEMA OPTIONS
    // ========================================================================

    // Automatically add createdAt and updatedAt timestamps
    timestamps: true,

    // Customize toJSON transformation
    // This removes sensitive fields when converting to JSON
    toJSON: {
      virtuals: true,                               // Include virtual fields
      transform: function (doc, ret) {
        // Remove password from JSON output
        delete ret.password;
        // Remove MongoDB internal fields
        delete ret.__v;
        return ret;
      },
    },

    // Customize toObject transformation
    toObject: {
      virtuals: true,
    },
  }
);

// ============================================================================
// VIRTUAL FIELDS
// ============================================================================

/**
 * Full Name Virtual Field
 *
 * Computed property that combines firstName and lastName
 * Not stored in database, calculated on the fly
 *
 * Usage: user.fullName
 */
userSchema.virtual('fullName').get(function () {
  return `${this.firstName} ${this.lastName}`;
});

// ============================================================================
// INDEXES
// ============================================================================

// Compound index for email lookups with status
// Optimizes queries that filter by email and status
userSchema.index({ email: 1, status: 1 });

// Index for role-based queries
userSchema.index({ role: 1 });

// ============================================================================
// PRE-SAVE MIDDLEWARE
// ============================================================================

/**
 * Password Hashing Middleware
 *
 * Automatically hashes the password before saving to database
 * Only runs if password field has been modified
 *
 * Process:
 *   1. Check if password has been modified
 *   2. Generate salt (10 rounds)
 *   3. Hash password with salt
 *   4. Replace plain password with hash
 *
 * Security:
 *   - Uses bcrypt for industry-standard hashing
 *   - Salt rounds = 10 (good balance of security and performance)
 *   - Plain text password never stored in database
 */
userSchema.pre('save', async function (next) {
  // Only hash the password if it has been modified (or is new)
  if (!this.isModified('password')) {
    return next();
  }

  try {
    // Generate salt
    // Cost factor: 10 rounds (2^10 iterations)
    // Higher = more secure but slower
    const salt = await bcrypt.genSalt(10);

    // Hash password with generated salt
    this.password = await bcrypt.hash(this.password, salt);

    next();
  } catch (error) {
    next(error);
  }
});

/**
 * Set isAdmin Flag Middleware
 *
 * Automatically sets isAdmin flag based on user role
 * Admin roles: MEMBER_ADMIN, CONTENT_ADMIN, NEWSLETTER_ADMIN, SUPER_ADMIN
 *
 * This pre-save hook ensures the isAdmin flag is always accurate
 * even if manually changed or role is updated
 */
userSchema.pre('save', function (next) {
  // Define admin roles
  const adminRoles = ['MEMBER_ADMIN', 'CONTENT_ADMIN', 'NEWSLETTER_ADMIN', 'SUPER_ADMIN'];

  // Set isAdmin flag based on role
  this.isAdmin = adminRoles.includes(this.role);

  next();
});

// ============================================================================
// INSTANCE METHODS
// ============================================================================

/**
 * Compare Password Method
 *
 * Compares a plain text password with the hashed password
 * Used during login authentication
 *
 * @param {string} candidatePassword - Plain text password to compare
 * @returns {Promise<boolean>} True if passwords match, false otherwise
 *
 * @example
 *   const user = await User.findOne({ email }).select('+password');
 *   const isMatch = await user.comparePassword('mypassword');
 *   if (isMatch) {
 *     // Password correct, log in user
 *   }
 */
userSchema.methods.comparePassword = async function (candidatePassword) {
  try {
    // bcrypt.compare handles the hashing and comparison
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw new Error('Error comparing passwords');
  }
};

/**
 * Update Last Login Method
 *
 * Updates the lastLogin timestamp to current time
 * Called after successful authentication
 *
 * @returns {Promise<User>} Updated user document
 *
 * @example
 *   await user.updateLastLogin();
 */
userSchema.methods.updateLastLogin = async function () {
  this.lastLogin = new Date();
  return await this.save();
};

/**
 * Is Approved Method
 *
 * Checks if user account is approved and active
 * Used to determine if user can access protected resources
 *
 * @returns {boolean} True if user is approved and active
 *
 * @example
 *   if (user.isApproved()) {
 *     // Grant access to protected features
 *   }
 */
userSchema.methods.isApproved = function () {
  return this.status === 'APPROVED' && this.isActive;
};

/**
 * Is Account Locked Method
 *
 * Checks if user account is currently locked due to failed login attempts
 * Account is considered locked if accountLockedUntil is in the future
 *
 * @returns {boolean} True if account is currently locked
 *
 * @example
 *   if (user.isAccountLocked()) {
 *     return res.status(403).json({ message: 'Account is locked' });
 *   }
 */
userSchema.methods.isAccountLocked = function () {
  // Check if accountLockedUntil exists and is in the future
  return this.accountLockedUntil && this.accountLockedUntil > Date.now();
};

/**
 * Increment Login Attempts Method
 *
 * Increments the failed login attempts counter
 * Locks account if maximum attempts (5) exceeded
 * Lock duration: 15 minutes
 *
 * @returns {Promise<User>} Updated user document
 *
 * @example
 *   // After failed login attempt
 *   await user.incrementLoginAttempts();
 */
userSchema.methods.incrementLoginAttempts = async function () {
  // Define lock settings
  const MAX_LOGIN_ATTEMPTS = 5;
  const LOCK_DURATION = 15 * 60 * 1000; // 15 minutes in milliseconds

  // Increment login attempts
  this.loginAttempts += 1;

  // If max attempts reached, lock account
  if (this.loginAttempts >= MAX_LOGIN_ATTEMPTS) {
    this.accountLockedUntil = new Date(Date.now() + LOCK_DURATION);
  }

  return await this.save();
};

/**
 * Reset Login Attempts Method
 *
 * Resets failed login attempts counter to zero
 * Clears account lock if present
 * Called after successful login
 *
 * @returns {Promise<User>} Updated user document
 *
 * @example
 *   // After successful login
 *   await user.resetLoginAttempts();
 */
userSchema.methods.resetLoginAttempts = async function () {
  // Only update if loginAttempts or accountLockedUntil are set
  if (this.loginAttempts > 0 || this.accountLockedUntil) {
    this.loginAttempts = 0;
    this.accountLockedUntil = null;
    return await this.save();
  }
  return this;
};

/**
 * Generate Auth Token Method
 *
 * Generates a JWT authentication token with user information
 * Token includes userId, email, role, and isAdmin flag
 * Used for authentication and authorization
 *
 * @returns {string} JWT token
 *
 * @example
 *   const token = user.generateAuthToken();
 *   res.json({ token, user });
 */
userSchema.methods.generateAuthToken = function () {
  const jwt = require('jsonwebtoken');

  // Get JWT configuration from environment
  const JWT_SECRET = process.env.JWT_SECRET;
  const JWT_EXPIRE = process.env.JWT_EXPIRE || '24h';

  // Generate token with user information
  const token = jwt.sign(
    {
      userId: this._id,
      email: this.email,
      role: this.role,
      isAdmin: this.isAdmin,
    },
    JWT_SECRET,
    {
      expiresIn: JWT_EXPIRE,
    }
  );

  return token;
};

// ============================================================================
// STATIC METHODS
// ============================================================================

/**
 * Find by Email Static Method
 *
 * Helper method to find a user by email address
 * Includes password field for authentication
 *
 * @param {string} email - Email address to search for
 * @returns {Promise<User|null>} User document or null if not found
 *
 * @example
 *   const user = await User.findByEmail('user@example.com');
 */
userSchema.statics.findByEmail = function (email) {
  return this.findOne({ email: email.toLowerCase() }).select('+password');
};

// ============================================================================
// CREATE AND EXPORT MODEL
// ============================================================================

/**
 * User Model
 *
 * Compiled Mongoose model from userSchema
 * Provides interface for CRUD operations on users collection
 */
const User = mongoose.model('User', userSchema);

module.exports = User;

// ============================================================================
// END OF USER MODEL
// ============================================================================
